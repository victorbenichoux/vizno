{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Layout python visualizations in HTML reports. vizno allows you to generate lightweight, portable and servable reports by laying out text and graphics together. Check out the demonstration report for a demonstration of what it looks like, it's a single HTML file! Installation \u00b6 Install vizno with PyPI: pip install vizno Quick start \u00b6 Create a python script my_report.py : from vizno.report import Report r = Report ( title = \"Report title\" , description = \"Here goes the report _description_.\" , ) # Write your figure generating code here ... f = ... r . widget ( f , title = \"Widget title\" , description = \"widget description\" ) At this point you have several options to generate the result. Either: use the vizno CLI, and run a local HTTP server bash vizno serve my_report.py use the vizno CLI to generate a standalone HTML and associated files to directory : bash vizno render reports/demo.py --output-dir directory programmatically write to the directory with a r.render(output_dir) statement and simply run the python file bash python reports/demo.py","title":"Index"},{"location":"#installation","text":"Install vizno with PyPI: pip install vizno","title":"Installation"},{"location":"#quick-start","text":"Create a python script my_report.py : from vizno.report import Report r = Report ( title = \"Report title\" , description = \"Here goes the report _description_.\" , ) # Write your figure generating code here ... f = ... r . widget ( f , title = \"Widget title\" , description = \"widget description\" ) At this point you have several options to generate the result. Either: use the vizno CLI, and run a local HTTP server bash vizno serve my_report.py use the vizno CLI to generate a standalone HTML and associated files to directory : bash vizno render reports/demo.py --output-dir directory programmatically write to the directory with a r.render(output_dir) statement and simply run the python file bash python reports/demo.py","title":"Quick start"},{"location":"cli/","text":"vizno provides a command line interface to generate reports: Render as a server \u00b6 Render the report and serve it within a webserver. This will automatically reload the page on changes to the report file. vizno render path/to/you/report.py serve Render to directory \u00b6 vizno render path/to/you/report.py --output-dir path/to/generate [ --reload ] Turning the --reload flag on will re-generate the report if the report file changes.","title":"CLI"},{"location":"cli/#render-as-a-server","text":"Render the report and serve it within a webserver. This will automatically reload the page on changes to the report file. vizno render path/to/you/report.py serve","title":"Render as a server"},{"location":"cli/#render-to-directory","text":"vizno render path/to/you/report.py --output-dir path/to/generate [ --reload ] Turning the --reload flag on will re-generate the report if the report file changes.","title":"Render to directory"},{"location":"renderers/","text":"Elements \u00b6 Given a Report object, add elements to it by calling the Report.widget , Report.header or Report.text Widgets \u00b6 Widgets are the most importan elements because they can contain visualizations: r = Report () r . widget ( content , name = \"Title\" , description = \"Description\" , layout = { \"width\" : 6 , newline : True } ) content is a figure object, see below for supported options name appears as a header to the widget element description is markdown rendered below the widget content The layout grid is 12 units wide, 6 is half of the full widths. newline ensures that the widget is rendered on a new line Markdown \u00b6 All titles and descriptions support Markdown text using snarkdown . It is also possible to render a text element instead of a widget: r = Report () r . text ( \"Some **Markdown** text\" ) Header \u00b6 Finally, one can add header sections to the Report object: r = Report () r . text ( title = \"A header\" , description = \"Markdown that goes directly below the header\" ) Widget contents \u00b6 vizno lays out and renders your Python visualizations in lightweight web pages. They can either be shared as standalone files, or rendered with fastAPI. It supports rendering from the major Python visualization libraries: Matplotlib \u00b6 It is possible to render matplotlib figures within a vizno widget. The figure has to be a matplotlib.pyploy.Figure subclass, and will be exported to SVG and included in the final report. The figure object is exported as an SVG using the Agg interface, and is then cleaned before being passed to the backend. This cleaning process is tweakable through keyword arguments passed to the Report.widget call (see the SVG section). Checkout the examples/renderers/matplotlib.py for an example, and the resulting report . Altair \u00b6 altair charts can be rendered by passing them as the first argument of the Report.widget() function. They have to be instances of altair.Chart . They are rendered by using the Chart.to_dict() function, and in the frontend by the vega JS library. Checkout the examples/renderers/altair.py for an example, and the resulting report . Bokeh \u00b6 bokeh models can be rendererd by passing them as the first argument of the Report.widget() function. They have to be instances of bokeh.models.Model . They are rendered by using bokeh.embed.json_item and then by BokehJS in the frontend. Checkout the examples/renderers/bokeh.py for an example, and the resulting report . Plotly \u00b6 plotly components can be rendered by passing them as the first argument of the Report.widget() function. They have to be instances of plotly.basedatatypes.BaseFigure . They are rendered by first saving them using BaseFigure.to_dict() method, and by plotly.js in the frontend. Checkout the examples/renderers/plotly.py for an example, and the resulting report . Pygal \u00b6 pygal charts can be rendered by passing them as the first argument of the Report.widget() function. They have to be instances of pygal.graph.graph.Graph . They are rendered as SVG using pygal 's Graph.render(disable_xml_declaration=True) function and pass through the same cleaning process as the other SVG contents (see below). Checkout the examples/renderers/pygal.py for an example, and the resulting report . SVG \u00b6 SVG rendering can be tweaked with keyword arguments passed to the Report.widget calls. inherit_font (default True ) the font inside the figure is replaced by the report's font width / height override the width/height of the SVG in inches scale (default down ) control the scaling behavior of the SVG: full sets the width/height to 100% of the parent container. fixed sets the specified widths and heights, down preserves the height of the original SVG, and sets the width to 100% . Data \u00b6 It also supports displaying large pandas dataframes as tables (using tabulator ). Checkout the examples/renderers/table.py for an example, and the resulting report . Typesetting \u00b6 Code \u00b6 It is possible to render syntax-highlighted code with highlightjs . To do so, pass a CodeContent structure to Report.widget , for example: from vizno.renderers.code import CodeContent r . widget ( CodeContent ( code = \"\"\" def do_something(argument): print(f\"Hello {argument} !\") do_something(\"ok) \"\"\" , language = \"python\" , ) ) Checkout the examples/renderers/code.py for an example, and the resulting report . LaTeX \u00b6 It is possible to render full LaTeX documents by passing a LatexContent(text=...) object to a widget. It will be rendered with latex.js . Checkout the examples/renderers/latex.py for an example, and the resulting report . MathJax \u00b6 It is possible to render full MathJax documents by passing a MathJaxContent(text=...) object to a widget. It will be rendered with mathjax . Checkout the examples/renderers/mathjax.py for an example, and the resulting report . Custom rendering \u00b6 !!! warning This section requires some knowledge of JS/React It is possible to provide a completely custom renderer that will render its content inside a widget. To do so you need two files. In the python file, define the necessary configurations and register your rendering function with the main vizno.renderers.render dispact. as so: import pydantic from vizno.renderers import ContentConfiguration , render from vizno.report import Report class CustomObject ( pydantic . BaseModel ): ... class CustomRenderConfiguration ( ContentConfiguration ): ... @render . register def _ ( obj : CustomObject ): ... return CustomRenderConfiguration ( component = \"MyCustomComponent\" , component_module = \"my_renderer.js\" , parameter = obj . parameter ) The second file should expose a custom Preact+htm component. Its props will be the fields of the ContentConfiguration defined in the python file. Here is a possible content for my_renderer.js : function MyCustomComponent ( props ) { return html `<p>something</p>` ; } When rendering, the my_renderer.js file will be moved to within the render directory (or served as a static file). When vizno-core.js encounters a widget content that has component_module=\"my_renderer.js\" it will attempt to import it (by adding a script node), and then render the content by looking for window.MyCustomComponent . Checkout the examples/custom_renderer/custom_renderer.py for an example. With external dependencies \u00b6 If you need external dependencies, you first need to define them in Python. Add the necessary URLs as lists of strings in the external_js_dependencies and external_css_dependencies fields of the of the ContentConfiguration you return. In JS you can use the custom useDependencies hook which will import dependencies for you (no need to import it) and make sure that they are correctly loaded before rendering (as well as controlling that each external library is only loaded once). A typical pattern looks like this: In Python: @render . register def _ ( obj : CustomObject ): ... return CustomRenderConfiguration ( component = \"MyCustomComponent\" , component_module = \"my_renderer.js\" , parameter = parameter external_js_dependencies = [ \"https://where.my/js/lives\" , ... ] external_js_dependencies = [ \"https://where.my/css/lives\" , ... ] ) In my_renderer.js : function MyCustomComponent ({ external_js_dependencies , external_css_dependencies , some_parameter , }) { const ready = useDependencies ({ componentName : \"MyCustomComponent\" , jsDependencies : external_js_dependencies , cssDependencies : external_css_dependencies , }); const divRef = useRef ( null ); useEffect (() => { if ( divRef . current && ready ) { window . YourImportedLibrary . doSomething ( divRef . current , some_parameter ); } }, [ divRef , ready , some_parameter ]); return html `<div ref=\" ${ divRef } \" />` ; }","title":"Widgets"},{"location":"renderers/#elements","text":"Given a Report object, add elements to it by calling the Report.widget , Report.header or Report.text","title":"Elements"},{"location":"renderers/#widgets","text":"Widgets are the most importan elements because they can contain visualizations: r = Report () r . widget ( content , name = \"Title\" , description = \"Description\" , layout = { \"width\" : 6 , newline : True } ) content is a figure object, see below for supported options name appears as a header to the widget element description is markdown rendered below the widget content The layout grid is 12 units wide, 6 is half of the full widths. newline ensures that the widget is rendered on a new line","title":"Widgets"},{"location":"renderers/#markdown","text":"All titles and descriptions support Markdown text using snarkdown . It is also possible to render a text element instead of a widget: r = Report () r . text ( \"Some **Markdown** text\" )","title":"Markdown"},{"location":"renderers/#header","text":"Finally, one can add header sections to the Report object: r = Report () r . text ( title = \"A header\" , description = \"Markdown that goes directly below the header\" )","title":"Header"},{"location":"renderers/#widget-contents","text":"vizno lays out and renders your Python visualizations in lightweight web pages. They can either be shared as standalone files, or rendered with fastAPI. It supports rendering from the major Python visualization libraries:","title":"Widget contents"},{"location":"renderers/#matplotlib","text":"It is possible to render matplotlib figures within a vizno widget. The figure has to be a matplotlib.pyploy.Figure subclass, and will be exported to SVG and included in the final report. The figure object is exported as an SVG using the Agg interface, and is then cleaned before being passed to the backend. This cleaning process is tweakable through keyword arguments passed to the Report.widget call (see the SVG section). Checkout the examples/renderers/matplotlib.py for an example, and the resulting report .","title":"Matplotlib"},{"location":"renderers/#altair","text":"altair charts can be rendered by passing them as the first argument of the Report.widget() function. They have to be instances of altair.Chart . They are rendered by using the Chart.to_dict() function, and in the frontend by the vega JS library. Checkout the examples/renderers/altair.py for an example, and the resulting report .","title":"Altair"},{"location":"renderers/#bokeh","text":"bokeh models can be rendererd by passing them as the first argument of the Report.widget() function. They have to be instances of bokeh.models.Model . They are rendered by using bokeh.embed.json_item and then by BokehJS in the frontend. Checkout the examples/renderers/bokeh.py for an example, and the resulting report .","title":"Bokeh"},{"location":"renderers/#plotly","text":"plotly components can be rendered by passing them as the first argument of the Report.widget() function. They have to be instances of plotly.basedatatypes.BaseFigure . They are rendered by first saving them using BaseFigure.to_dict() method, and by plotly.js in the frontend. Checkout the examples/renderers/plotly.py for an example, and the resulting report .","title":"Plotly"},{"location":"renderers/#pygal","text":"pygal charts can be rendered by passing them as the first argument of the Report.widget() function. They have to be instances of pygal.graph.graph.Graph . They are rendered as SVG using pygal 's Graph.render(disable_xml_declaration=True) function and pass through the same cleaning process as the other SVG contents (see below). Checkout the examples/renderers/pygal.py for an example, and the resulting report .","title":"Pygal"},{"location":"renderers/#svg","text":"SVG rendering can be tweaked with keyword arguments passed to the Report.widget calls. inherit_font (default True ) the font inside the figure is replaced by the report's font width / height override the width/height of the SVG in inches scale (default down ) control the scaling behavior of the SVG: full sets the width/height to 100% of the parent container. fixed sets the specified widths and heights, down preserves the height of the original SVG, and sets the width to 100% .","title":"SVG"},{"location":"renderers/#data","text":"It also supports displaying large pandas dataframes as tables (using tabulator ). Checkout the examples/renderers/table.py for an example, and the resulting report .","title":"Data"},{"location":"renderers/#typesetting","text":"","title":"Typesetting"},{"location":"renderers/#code","text":"It is possible to render syntax-highlighted code with highlightjs . To do so, pass a CodeContent structure to Report.widget , for example: from vizno.renderers.code import CodeContent r . widget ( CodeContent ( code = \"\"\" def do_something(argument): print(f\"Hello {argument} !\") do_something(\"ok) \"\"\" , language = \"python\" , ) ) Checkout the examples/renderers/code.py for an example, and the resulting report .","title":"Code"},{"location":"renderers/#latex","text":"It is possible to render full LaTeX documents by passing a LatexContent(text=...) object to a widget. It will be rendered with latex.js . Checkout the examples/renderers/latex.py for an example, and the resulting report .","title":"LaTeX"},{"location":"renderers/#mathjax","text":"It is possible to render full MathJax documents by passing a MathJaxContent(text=...) object to a widget. It will be rendered with mathjax . Checkout the examples/renderers/mathjax.py for an example, and the resulting report .","title":"MathJax"},{"location":"renderers/#custom-rendering","text":"!!! warning This section requires some knowledge of JS/React It is possible to provide a completely custom renderer that will render its content inside a widget. To do so you need two files. In the python file, define the necessary configurations and register your rendering function with the main vizno.renderers.render dispact. as so: import pydantic from vizno.renderers import ContentConfiguration , render from vizno.report import Report class CustomObject ( pydantic . BaseModel ): ... class CustomRenderConfiguration ( ContentConfiguration ): ... @render . register def _ ( obj : CustomObject ): ... return CustomRenderConfiguration ( component = \"MyCustomComponent\" , component_module = \"my_renderer.js\" , parameter = obj . parameter ) The second file should expose a custom Preact+htm component. Its props will be the fields of the ContentConfiguration defined in the python file. Here is a possible content for my_renderer.js : function MyCustomComponent ( props ) { return html `<p>something</p>` ; } When rendering, the my_renderer.js file will be moved to within the render directory (or served as a static file). When vizno-core.js encounters a widget content that has component_module=\"my_renderer.js\" it will attempt to import it (by adding a script node), and then render the content by looking for window.MyCustomComponent . Checkout the examples/custom_renderer/custom_renderer.py for an example.","title":"Custom rendering"},{"location":"renderers/#with-external-dependencies","text":"If you need external dependencies, you first need to define them in Python. Add the necessary URLs as lists of strings in the external_js_dependencies and external_css_dependencies fields of the of the ContentConfiguration you return. In JS you can use the custom useDependencies hook which will import dependencies for you (no need to import it) and make sure that they are correctly loaded before rendering (as well as controlling that each external library is only loaded once). A typical pattern looks like this: In Python: @render . register def _ ( obj : CustomObject ): ... return CustomRenderConfiguration ( component = \"MyCustomComponent\" , component_module = \"my_renderer.js\" , parameter = parameter external_js_dependencies = [ \"https://where.my/js/lives\" , ... ] external_js_dependencies = [ \"https://where.my/css/lives\" , ... ] ) In my_renderer.js : function MyCustomComponent ({ external_js_dependencies , external_css_dependencies , some_parameter , }) { const ready = useDependencies ({ componentName : \"MyCustomComponent\" , jsDependencies : external_js_dependencies , cssDependencies : external_css_dependencies , }); const divRef = useRef ( null ); useEffect (() => { if ( divRef . current && ready ) { window . YourImportedLibrary . doSomething ( divRef . current , some_parameter ); } }, [ divRef , ready , some_parameter ]); return html `<div ref=\" ${ divRef } \" />` ; }","title":"With external dependencies"},{"location":"rendering/","text":"As standalone files \u00b6 vizno reports generated by calling render in the python code, or using the vizno render CLI are standalone, and can be opened by openting index.html in the browser. If the report depends on JS packages, they will be loaded at runtime. Although they can be retained in cache, they are not packaged alongside the document itself: opening the report requires an internet connection (except for SVG only renderers, i.e. matplotlib/pygal). In a FastAPI server \u00b6 vizno.api exposes a fastapi.FastAPI subclass that allows you to quickly server vizno reports from a fastapi app. from vizno.api import ViznoApp from vizno.report import Report app = ViznoApp () @app . report ( \"/your/endpoint/path\" ) def f (): r = Report () # populate the report with elements... return r . get_configuration () The app can then be mounted within your main FastAPI application. Using arguments \u00b6 The @app.report decorator behaves mucbeh like a usual @app.get decorator in fastapi , and in particular it is possible to pass it arguments, which will be parsed when the report is requested. See the example in examples/api . How it works \u00b6 When initialized: app = ViznoApp ( static_url : str = \"/static\" , ** kwargs ) creates a FastAPI app, and serves all static vizno files (JS, CSS, logo, index.html ) under the /static path (using fastapi.staticfiles.StaticFiles ). When the report decorator is called: @app . report ( \"/your/endpoint/path\" ) def f ( value : Optional [ str ] = None ) : r = Report () # populate the report with elements ... return r . get_configuration () It creates creates two endpoints in the viznoapp : a GET endpoint at /your/endpoint/path_config , with arguments/options specified as in fastapi from the function arguments. This endpoint will be called by the JS code in index.html to produce the report. a GET endpoint at /your/endpoint/path with the same with arguments/options. It will redirected towards /static/index.html with options set such that index.html will know to retrieve the configuration.","title":"Rendering"},{"location":"rendering/#as-standalone-files","text":"vizno reports generated by calling render in the python code, or using the vizno render CLI are standalone, and can be opened by openting index.html in the browser. If the report depends on JS packages, they will be loaded at runtime. Although they can be retained in cache, they are not packaged alongside the document itself: opening the report requires an internet connection (except for SVG only renderers, i.e. matplotlib/pygal).","title":"As standalone files"},{"location":"rendering/#in-a-fastapi-server","text":"vizno.api exposes a fastapi.FastAPI subclass that allows you to quickly server vizno reports from a fastapi app. from vizno.api import ViznoApp from vizno.report import Report app = ViznoApp () @app . report ( \"/your/endpoint/path\" ) def f (): r = Report () # populate the report with elements... return r . get_configuration () The app can then be mounted within your main FastAPI application.","title":"In a FastAPI server"},{"location":"rendering/#using-arguments","text":"The @app.report decorator behaves mucbeh like a usual @app.get decorator in fastapi , and in particular it is possible to pass it arguments, which will be parsed when the report is requested. See the example in examples/api .","title":"Using arguments"},{"location":"rendering/#how-it-works","text":"When initialized: app = ViznoApp ( static_url : str = \"/static\" , ** kwargs ) creates a FastAPI app, and serves all static vizno files (JS, CSS, logo, index.html ) under the /static path (using fastapi.staticfiles.StaticFiles ). When the report decorator is called: @app . report ( \"/your/endpoint/path\" ) def f ( value : Optional [ str ] = None ) : r = Report () # populate the report with elements ... return r . get_configuration () It creates creates two endpoints in the viznoapp : a GET endpoint at /your/endpoint/path_config , with arguments/options specified as in fastapi from the function arguments. This endpoint will be called by the JS code in index.html to produce the report. a GET endpoint at /your/endpoint/path with the same with arguments/options. It will redirected towards /static/index.html with options set such that index.html will know to retrieve the configuration.","title":"How it works"}]}